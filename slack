フォント幅は直りました。

KoRoN [18:26]

いい感じです。

image.png 

image.png

ujihisa [18:32]

Amigaで:terminalしよう

ichizok [18:39]



｀｀｀gvim --clean

:set nobuflisted

:terminal｀｀｀



ウインドウ閉じるボタンを押す

"Kill job ~?" ダイアログでOKを選択

=> ファイル選択ダイアログが出て、キャンセルを選ぶとダイアログが出続ける

これWindowsでも再現しますか？

mattn [18:49]

再現しません。

ichizok [19:00]

ありがとうございます。unixだけかな

あいや [19:21]

string-interplation用のテストを書いてみました！

どうだろ……。

https://gist.github.com/b7d999fbfa4f652de697337b3fb7b6ae

thinca [19:22]

文法は確定?

mattn [19:24]



｀｀｀`xxx`｀｀｀



内に ` は書ける？

あいや [19:29]

そうか、エスケープ関連忘れてました :祈る:



｀｀｀echo `\``

" `



echo `\${10}`

" ${10}



echo `$\{10}`

" ${10}



let _ = `${10\}`

" パースエラー！（ECMAScriptを参考）｀｀｀



あいや [19:37]

https://twitter.com/public_ai000ya/status/1133682855400181760?s=19

あいやあいや@public_ai000ya

あなたが期待する挙動val x = 10

print ｀${x}｀

print ｀$x｀

TwitterTwitter5月29日

mattn [19:58]

$x は環境変数とシンタックスがかぶって色付けしんどそう。

tyru [20:51]

https://github.com/vim/vim/pull/4446#issuecomment-496876334

Bram に「ほかのファイル :edit したりウィンドウ移ったりした時にも clear しないとアカンやんけ」って言われたんですが、役割的に window-local variable だったらいいと思うんですよね（できればの話）。

ただ w: はユーザが変更可能なので既存プラグインを壊さないとも限らない（そして Bram は絶対入れなさそう？）。

GitHubGitHub

Add v:searchstat variable by tyru · Pull Request #4446 · vim/vim

As of 8.1.1270, vim can show current match position and count like [1/20] at command-line. It is useful but cannot get the status from Vim script, without using execute(&#39;:unsilent :norm! n&#39;...

そこでふと思ったんですが、ウィンドウローカルな ｀v:｀ とかってありましたっけ？というか、内部的にウィンドウ毎に別の ｀v:searchstat｀ の値を持たせる事が可能なのか知りたい

とはいうもののやっぱり window-local な値を持つ vim-variable とかややこしいし、どんなインターフェースがいいのかまた迷ってる段階です…

tyru [20:56]

となると window-local なオプションなのかなぁ

KoRoN [20:57]

基本的なところがわかってないんですが searchstat ってどういう値なんです?

tyru [20:58]

8.1.1270 から ｀set shortmess-=S｀ して ｀n｀, ｀N｀, ｀/｀ コマンドを実行すると、コマンドラインに ｀[1/20]｀ みたいなヒット件数と現在位置が出るようになったんですが（以前 vim-anzu みたいなやつが本体に入ったって言われてたので覚えてるかもしれませんが） （編集済み） 

その ｀[1/20]｀ を ｀{'current': 1, 'count': 20, 'wrap': 0}｀ みたいな値で参照可能にする変数です。

なぜ欲しいかはここら辺に書きました https://github.com/vim/vim/pull/4446 （編集済み） 

GitHubGitHub

Add v:searchstat variable by tyru · Pull Request #4446 · vim/vim

As of 8.1.1270, vim can show current match position and count like [1/20] at command-line. It is useful but cannot get the status from Vim script, without using execute(&#39;:unsilent :norm! n&#39;...

KoRoN [21:01]

ははーん…いま表示する時は1つだけど、それやるとWin毎に設定できるようになるんか。

tyru [21:03]

いや、設定は考えてないです。まず参照したいというモチベがあって、なぜ参照したいかというと

1. statusline に表示させたい (今はコマンドラインに表示される)

2. ｀nnoremap n nzz｀ みたいなマッピングを持ってると ｀zz｀ で画面が redraw してしまい見えなくなる （編集済み） 

KoRoN [21:03]

あ、スクリプトからという意味ではなく、Vim側からという意味。

なんか

1 をやるんだったら ｀'statusline'｀ に新しい item 追加したほうが正しいんじゃないの?

tyru [21:05]

はい。statusline だけだったらそれだけで事足りるんですよね…

分けた方がいいんですかね？

KoRoN [21:05]

正しいっていうか「説得力が出る」というべきかな。

tyru [21:05]

（まぁ正直自分としては usecase として示したかっただけで 2 が主な理由です）

KoRoN [21:06]

Vim script にマップするなら、関数追加でどう?

tyru [21:06]

うーん確かに…

KoRoN [21:06]

そうすればどこに入ってるかは気にならないし。たしかに shortmes は微妙だと僕も思う。

ただ…これ全バッファに出すと、めんどそう(再描画の精度と速度のトレードオフが生じそう)ってのはある。

tyru [21:07]

今まで関数を避けてた理由としては (↑の issue でも書いた) statusline で参照する時に若干のオーバーヘッドがある、くらいで

statusline に追加しちゃえばそれはなくなるんですよね…

関数にすればウィンドウ毎の値も取れるし汎用的になるんだけど、↑の理由があって変数を選んだ、って感じでした

KoRoN [21:08]

vimscriptから使うなら現在の値を取るよりは ｀search()｀ の亜種でそういう情報が取れるほうが汎用的で説得力あるかもしれない。

tyru [21:10]

念のため、それって設定とかは考えてる感じですか？参照だけでいいような気はしますが >｀search()｀ の亜種

KoRoN [21:10]

いや考えてないです。

searchの亜種っていうのは、いまのままだと最後の検索による情報しか取れないけど、任意のパターンで、検索のメタ情報(位置とか総件数とか)がわかるほうがなにかしら使い回しができて、Vim scriptから参照できる意味があるなぁ、くらいの発想。 （編集済み） 

tyru [21:16]

:naruhodo:

確かに関数にすればより汎用的にも展開できるしよさそう

KoRoN [21:17]

いっといてなんですが、too muchだとは思いますけどねw

tyru [21:17]

ただちょっと気になってるのが、関数にすると再検索が必要になっちゃって重くならないかというのがあった（当初考えていた時）

いや、ただ statusline は statusline で項目追加すべきはその通りだと思います

tyru [21:18]

大分頭整理出来てきた

KoRoN [21:18]

やっぱちらついたり消えたりってのを解消するってのは結構重要だと思うし、ちょうどよい変数の種類がないのもそのとおりなのでitemで追加しちゃうのがユーザーにとってもベストかなって思います。

itemに使えるアルファベットがないんじゃねぇか? っていう心配はあります。

記号は特殊な用途になってますね。

ソートされてないからわかりにくいけど ｀s｀ と ｀S｀ は空いてそう。

tyru [21:24]

おぉ、あざます！

まとめ

• statusline にも項目追加した方が良い

• Vim script から参照可能にするには？（以下懸念点）

   ◦ 変数 (v:) → ウィンドウ毎の値が取れない

   ◦ 変数 (w:) → ユーザが変更可能で互換性壊してしまうので×

   ◦ 関数 → 再検索のコストがかかってしまう

   ◦ オプション → 変更可能にしないとダメだし、値が文字列型に限られてしまう （編集済み） 

KoRoN [21:31]

変更可能にする意味がないからオプションはアウトな気がしますね。

っていうかstatuslineで取れるものにアクセスする関数ってあっても良いのでは?

# どんどん話を大きくしすぎてる感はあるw

tyru [21:34]

なんかそれが一番いい案な気がしてきましたｗ

関数のネックであるコストを回避するために何らかの形で (内部的に) 値を置いておく必要はあるなと感じてたんですが、

関数で (今は未対応？としても将来的に) 任意のパターンの検索を可能にするならキャッシュするのはメモリ的に不安だし

それなら ｀getcompletion()｀ の statusline 版みたいなの合ってもいいかも、みたいな （編集済み） 

KoRoN [21:37]

いまどこから取ってくればよいのか見てた。言い出しっぺの責任的なアレで

src/buffer.c の ｀build_stl_str_hl()｀ のなかに ｀case STL_xxx｀ なところで埋めてますね。

｀case STL_FILEPATH｀ で探せば見つかる。

この部分をいい感じに関数化して、vim scriptから使えるようにラッパーかぶせてっていうのが最短手かと。

いずれにせよまずはココに実装しちゃうのがはやそげ

tyru [21:43]

:kan: :kiwa: :mattekimashita:  あざます！

thinca [21:57]

任意のパターンで検索できる関数、パターンを省略すると ｀@/｀ が使われてその場合はキャッシュから取ってきて速くなるとかはアリな気がする

tyru [22:05]

その場合も関数の呼び出しコストは 0 にはならないというのが…（考えすぎな気はする）

thinca [22:07]

そこは Vim script 自体が将来高速化されることを期待しよう(雑)

tyru [22:08]

本当にそこは期待したい… 誰か…

なんだかんだ言って「statusline に表示」が一番頻出なユースケースだとは思うので、そのための項目追加はしたい → statusline の値を取れる関数を作る、ってのが一番シンプルだったのでｗ

mattn [22:08]

｀v:xxx｀ を引くのもコストなので (言い訳)

tyru [22:08]

それは確かに…

関数がコスト言いだしたらそれはそうなりますよね…

thinca [22:09]

正直なところ statusline に表示するのは大きなユースケースになりづらいと思っている

mattn [22:10]

あー、k-takata さんが言ってた Amiga 壊したってこれかw https://github.com/vim/vim/pull/4424#issuecomment-496786745

GitHubGitHub

Refactor delete() to use readdir() for fixing #696 by k-takata · Pull Request #4424 · vim/vim

This fixes the issue #696 by refactoring delete(). Move the core part of f_readdir() to readdir_core(). (ref: #2439) Stop using gen_expand_wildcards() from delete_recursive(). Use readdir_core() i...

thinca [22:11]

statusline に表示したい情報はウィンドウ(バッファ)毎に異なる情報になるのだけど、検索って多くの場合は現在のバッファに対してしたい場合がほとんど(プロジェクト横断でしたい場合もあるけど)。statusline に表示すると、現在のバッファでただ検索したいだけなのに表示されているすべてのバッファで検索が走ることになる。嬉しくないケースの方が多いと思う

tyru [22:14]

あーなるほど

Tsuyoshi CHO [22:14]

バッファ毎という意味だと行/桁と類似? at statusline

KoRoN [22:15]

今も別バッファで検索走ってるんすよ。ハイライトするのに。

thinca [22:15]

あーそう言われてみると…

KoRoN [22:15]

それはそれで個別に無効化できるべきではあるけど

thinca [22:15]

いろんな問題が絡まってきた

tyru [22:15]

例えば Chrome で検索欄が表示されてる時しか件数は表示されないけど、Vim の場合 statusline に含めたら常に表示される事になってしまう （編集済み） 

という問題は把握できた

KoRoN [22:16]

カーソルがあたってないから ｀[--/<99]｀ みたいな表示があれば、それはそれで役に立つのかなと。

thinca [22:16]

検索自体を回避できるようにしたら 99 も -- になるかな

KoRoN [22:16]

検索してない場合は消すか ｀[--/--]｀ とかね。例えばだけど。

thinca [22:17]

99 を変更できるようにオプションを足す件やろうかな。簡単そう

(…グローバルでいいよね…?)

KoRoN [22:18]

いまのままなら悪くてもタブごと、くらいの分離度になるかもしれない。

thinca [22:19]

ハイライトのための検索って実は見えてる範囲だけだったりはしないですかね?

全体検索してるなら 99 という上限があるのは不自然な気がして

tyru [22:24]

見間違えてなければ、バッファ先頭から ｀@/｀ を検索して 99 超えたら break してるだけだと思います (search_stat() search.c)

単純にファイルサイズが大きい場合 (例えば 20000 行越えの PHP ファイル) の速度を考慮したんじゃないですかね

thinca [22:26]

ヒット件数の方ではなくてハイライトのための検索ですね

tyru [22:27]

ハイライトの検索でも 99 件なんですか？

その上限ってどっかに書いてありますか？

というか



  今も別バッファで検索走ってるんすよ。ハイライトするのに。



は内部的な話だと思ってた

thinca [22:28]

いや、上限はないので、ハイライトの検索ではバッファ全体ではなく見えている範囲だけを検索しているんじゃないかなと思ったんです

ハイライトのための検索でバッファ全体を検索しているのであれば stat の方を 99 件に絞る意味がないので

tyru [22:29]

あー :naruhodo:

mattn [22:34]

@ゴリラ ゴリラさん、いまやってるの popup_getoptions です？

popup_getposition 出来たので送ってしまっていいですか？

ゴリラ [22:43]

optionsの方です！

mattn [22:43]

あざます。では getposition の方送ってしまいます。

ゴリラ [22:44]

getposition、参考にします！

mattn [22:44]

https://github.com/vim/vim/pull/4449

ゴリラ [22:44]

今上がったのでこれから電車の中でやります

よんだ

++dict->dv_refcount;

これは何してるんですか？

mattn [22:48]

vim の gc って2つ実装されてて、一つは参照カウント、もう一つは mark&sweep なんですが、その参照カウントの方を1足してます。これをしないと関数から値が返った瞬間に gc されて vim がクラッシュします。

ちなみになぜ gc が2つ実装されているかというと



｀｀｀let a = {}

let b = {"a": a}

let a["b"] = b｀｀｀



こうすると循環参照して参照カウントでは 0 にならないんです。これを解決する為に mark&sweep があります。

thinca [22:57]

とても丁寧な解説

mattn [23:07]

テストがコケている

ゴリラ [23:12]

ありがとうございます

参照カウントとmark&weepが全然わからないので調べてみますひとまず ｀++dict->dv_refcount;｀ は必要なのはわかりました

今直して、ビルド中…

通るかな

mattn [23:15]



｀｀｀function X()

  let a = {}

endfunction｀｀｀



関数 X を呼び終わると a を格納してるメモリって必要ないので解放できますよね。a が出来た時に参照カウントを +1、関数を終了した際に -1 すれば a の参照カウントは 0 つまり解放してよい事になります。



｀｀｀function X()

  let a = {}

  return a

endfunction｀｀｀



この場合、return の際に内部的に +1 がされてて関数を抜けてもメモリを解放しない様にしてあるんです。これが参照カウント。

mark&sweepは↑に書いた通り、循環参照が解決できないので他の方法を使って「もう必要ない」を判定しています。

KoRoN [23:17]

そもそもGCの代表的な実装方式、みたいな概念がないのでは?

mattn [23:18]

方法としては「全てのオブジェクトはルートから辿れる」という事から、全てのオブジェクトにフラグを持たせて

1. 全てのフラグをクリアする

2. 全てのオブジェクトを辿ってフラグをonにする

3. フラグがonになっていない物は誰からも参照されてないので解放する

こうするのが mark&sweep

KoRoN [23:18]

# とかいってると「参照カウントをGCと呼んではいけない」オジサンが出てくるかもしれない

mattn [23:18]

ですねw

thinca [23:19]

collect してないので GC ではない!!111 (?)

mattn [23:19]

続き) で、なぜ全部 mark&sweep でやらないの？という話になるんですが、手順を見て貰うと分かる通り重たいんですね。つまり稀にしか実行できない。よってメモリが増え続ける可能性がある。 （編集済み） 

ゴリラ [23:22]

丁寧な説明ありますございますm(_ _)m

参照カウントについては理解しましたが、mark&sweepはまだ漠然としているので、ちょっと調べます

mattn [23:22]

この辺は今すぐ覚える必要はないですね。

KoRoN [23:23]

ちなみにゴリラさんがメインで使ってる言語ってgoですか?

ゴリラ [23:23]

https://github.com/skanehira/vim/commit/6f8caffe5964a4e7c52408f3bd108ae4b4a69054

いま実装直しましたが、やはり ｀call popup_getoptions｀ でSEGVになる…

GitHubGitHub

add popup_getoptions · skanehira/vim@6f8caff

The official Vim repository. Contribute to skanehira/vim development by creating an account on GitHub.

メインはGoというより、Goをメインにしたいって感じでGo勉強していますね

いまはJavaとActionScriptを書いてます

mattn [23:24]

w_popup_timer が NULL だらかですね。

ゴリラ [23:24]

あれ、timerってまだ実装されていないんですか？

mattn [23:24]

いえ、指定されてない場合は ｀wp->w_popup_timer｀ は NULL です。

ゴリラ [23:24]

ヘルプを見ると`{not implemented yet}` なかったので

あー

なるほど

mattn [23:25]



｀｀｀if (wp->w_popup_timer != NULL) {

  dict_add_number(dict, "time", (long)wp->w_popup_timer->tr_interval);

}｀｀｀



ゴリラ [23:25]

NULLかを見ないといけないのか

ありがとうざいます

mattn [23:25]

:okサイン:

ゴリラ [23:27]

ちなみに、参照カウントの話ですが

｀++dict｀ はどういうときに使うのですか？

動きは理解しましたが、使う時がわからない。。。。

rbtnn [23:28]

Cはほかの言語以上にNULLチャックしとかないと簡単にSEGVするので、とりあえず入れとけって程度がいい

ゴリラ [23:28]

なるほど

NULLチェック、こまめにですね

｀{'col': 0, 'zindex': 50, 'maxwidth': 0, 'line': 0, 'minwidth': 0, 'minheight': 0, 'maxheight': 0}｀

実行できた

あとテスト追加したらPR出せる

タイムオーバー…

明日か…

mattn [23:31]

参照カウントの話をもう一度簡単に説明すると、誰かがそのオブジェクトを見ていれば +1 される、つまり誰も見なくなったら 0 です。この関数 popup_getoptions は戻り値として値を返すので +1 しておく必要があります。



｀｀｀call popup_getoptions(x) " これは 1、そのあと関数を抜けて 0｀｀｀



｀｀｀let a = popup_getoptions(x) " これは 1、a に代入されて 2｀｀｀



（編集済み）

mattn [23:32]



｀｀｀let a = "foo"｀｀｀ 



この瞬間に a の中身のオブジェクトの参照カウントが減って 1、その後スコープを抜けて 0 （編集済み） 

プログラミング言語ってこういう感じに作られてます。

ゴリラ [23:36]



  この瞬間に a の中身のオブジェクトの参照カウントが減って 1、その後 gc で 0



0になったらgc対象になりgcされるのではなく

gcで0になるんですか？

mattn [23:36]

変数のスコープによります。関数で作られたオブジェクトなら関数が終了する際に 0 になります。

gc されて、はちょっと間違いを誘導するのでちょっと直しますね。

ゴリラ [23:38]

参照数 = カウント数

カウント数 = 0 = gcされる対象 = gc

って理解ですが合ってますか？

mattn [23:38]

はい。

gc と呼んでしまったのは僕の間違いですね。

KoRoN [23:38]

# だいたいのやつは0になった瞬間に開放するので、0になる→開放する→GCされたことになる、ってのがより正確。

ゴリラ [23:39]

↑の認識です

thinca [23:39]

「a に代入されて 2」1ではない? 一瞬だけ2になる?

mattn [23:40]

2 になって ｀let a = "foo"｀ みたいな再代入で 1 かな。

ゴリラ [23:41]



｀｀｀function X()

  let a = {}

  return a

endfunction｀｀｀



↑の場合、aはカウント+1しないといけないんですよね？

mattn [23:42]

｀let a = {}｀ で 1、return で 2 かな。

ゴリラ [23:42]

あ

そそ

mattn [23:42]

で関数を抜ける際に 1 に戻るか。

あ、↑の少し違うな。

いや、あってる。

まぁ参照カウントはまだデバッグが楽ですよ。

落ちたらつまりは +1 が足らないって話です。

ゴリラ [23:44]

returnで+1してるのがよく分からなくて

戻り値を変数に代入しないと参照増えないんですよね？

増えないのに+1するのがよく分からないです

mattn [23:45]

消えて欲しくないから意図的に +1 してるんです。

ゴリラ [23:46]

そしたら、どのタイミングで-1されてgcされるんですか？ （編集済み） 

代入しない時は

あー、

rbtnn [23:49]

｀{}｀ で自分自身で保持しているから+1

｀let a =｀ でaに参照をされるから+1

｀let a = "..."｀ で再代入されると-1

こんな感じかなぁ

mattn [23:50]

はい。

ゴリラ [23:50]

あー、popup_getoptionsの値が消えて欲しくないって作りになってるってことか

mattn [23:50]

はい。

もう少し細かい話をすると、プログラミング言語のスコープって辞書みたいな物なんです。

Vim はまだ分かりやすくて ｀l:｀ が関数スコープですよね。関数を抜ける際にその ｀l:｀ をクリアするんです。クリアする際に ｀l:obj｀ が {} だった場合はそのまま消さずに参照カウントを減らしてみる、0 だったらメモリ解放、1 以上だったら ｀s:｀ 等から参照されてるか、return されてるから解放しない、という動きです。(お掃除処理) （編集済み） 

ゴリラ [23:55]

returnされてる場合は基本解放しない理由がよくわからないんですが、vimはそういうお作法ですか？

代入してる可能性があるから？

mattn [23:55]

いえ、参照カウント使ってる言語ならどの言語もです。 （編集済み） 

ゴリラ [23:56]

代入してる可能性があるから解放しない

代入してない場合カウント1のオブジェクトはどのタイミングで-1され、gcされるんですか？ （編集済み） 

mattn [23:57]

今↑にお掃除処理と書いたんですが、このお掃除処理の際に return する予定だったものが解放されたら困りますよね？

なので return で意図的に増やすんです。

return って「これを返すぞ」という予約であって、そのあとお掃除が実行される事になります。

予約つまり「消すなよ」という意味で +1

thinca [00:00]

焦らしプレイ

ゴリラ [00:00]

あー、お掃除処理があるんですね

あー、

あー

mattn [00:01]

気付き力

m_nishi [00:03]

今日は残念ながら全然追えてないけど、Slack に残しておく (流れてしまう) にはもったいない内容だ。。

mattn [00:03]

ちなみに昔、C言語で orelang (俺言語) というのを書いたんですが

https://github.com/mattn/orelang/blob/f5c36d7f69e3963e9fbd6a6f18fcca4cc1388fea/ore.c#L1606

GitHubGitHub

mattn/orelang

俺言語. Contribute to mattn/orelang development by creating an account on GitHub.

ここ return の部分です。ore_value_ref で参照カウントを増やしてます。

あとプログラミング言語を作ってみたい方で、まだそれほど自信の無い方

https://qiita.com/shuetsu@github/items/ac21e597265d6bb906dc

QiitaQiita

プログラミング言語を作る。１時間で。 - Qiita

あなたは、プログラミング言語を作ったことがありますか？ エッ！？ない！？ それはいけない。いますぐ作りましょう。１時間ぐらいで。 10/3追記 続編を書きました。 http://qiita.com/shuetsu@github/it...

これを自分の言語で作ってみるといいですよ。

この言語は GC 無いですが、プログラムがどういう風に作られるのかが理解できるはず。

ちなみに orelang という名前ですが、僕の orelang とは関係ないです。

この例、プログラムを理解するのには良いと思います。

わかる人は「なんや S 式や」となるはず

thinca [00:10]

今 dict.c 眺めてたら ｀rettv_dict_set()｀ って関数があったんですが、さっきの mattn さんのパッチでこれを使ってないのって何か理由があるんでしょうか?

mattn [00:11]

あ、いや単にその関数の存在を失念してただけです。

多分、他所でもその関数使ってない所いっぱいあるはずw

thinca [00:12]

結構頻出しそうなパターンの割に grep かけてもあまり使われていない…w

mattn [00:12]

ですね。

5か所しか使ってないw

誰か、使う様にする pull-request チャンスですね。 （編集済み） 

ゴリラ [00:15]

カウントの話し

一点確認ですが、returnしても代入されない場合、お掃除処理でgcされんですよね？

mattn [00:15]

はい。

thinca [00:15]

ところが ｀rettv->v_type = VAR_DICT｀ と言うコードはこの関数自体以外だと if_ruby で1箇所のみだ。ほんまかな?

mattn [00:16]

｀v_type = VAR_DICT｀ の方がいいかも

僕の方は直しておくかな。

ゴリラ [00:17]

なるほど

ズレてるところ理解した

thinca [00:18]

圧倒的理解力

ゴリラ [00:18]

多分分かったと思うけど、もう少し整理します

明日また質問するかもですw

mattn [00:18]

vim 開発者育成チャネル

てんなし [00:18]

このスレッドに返信しました :

参照カウントの話をもう一度簡単に説明すると、誰かがそのオブジェクトを見ていれば +1 される、つまり誰も見なくなったら 0 です。この関数 popup_getoptions は戻り値として値を返すので +1 しておく必要があります。…

これって、`call popup... ｀の例は｀ call` だけして関数が終了するって認識であってますか?

mattn [00:30]

↑の orelang の記事、何度読んでもうまく出来てる記事だなぁと思って見てたら書いた人 SICP とかやってて、あぁなるほどねとなった。 （編集済み） 

ゴリラ [00:43]

orelangの記事読んで、gorilang作る(そのうち

mattn [00:44]

ゴリラという名前、力あるなぁw

orelang の記事ので言語が作れると、たぶん純 lisp が作れます。

あ、いや、car/cdr は難しいか。

まぁでもそれっぽいのが出来ます。

call の場合は明示的に unref 出来るけど lambda 内で式と {} を返す様な関数を呼び出したりタイマー関数の中で {} を返す様な関数を呼び出すと、それはおそらく mark&sweep になりますね。

akiyosi [00:52]

#dev に参加しました。

thinca [01:27]

全部は見てないけど、あちこち見た感じやはり不要になった瞬間に参照カウント下げてる気がする。タイマー関数の戻り値もきちんと処理している。循環参照以外に mark&sweep が必要になるタイミングは、ないと信じたい

KoRoN [01:59]

なんかあった気がするんだよな…なんだったかな

もう使わないリストにぶら下げて、mark&sweepに任せるやつが。

lambda やってたときに「へーこんなことしてんだ」って。

コード見ないと詳細思い出せないな。まったく別のやつの可能性もなきにしもあらず。

thinca [08:14]

お、popup の幅が最初の行しか見られないの直ったっぽい

ゴリラ [08:22]

vimのテストを個別に走らせるやり方ってありますか？

追加したテストの部分だけ実行したいです

rbtnn [08:22]

make test_xxx.res

ゴリラ [08:23]

あ、あとテストの実行方法を教えて頂けると助かりますm(_ _)m

rbtnn [08:23]

testdir内で

mattn [08:25]

簡単にやりたいなら書いた test_xxx.vim を出来上がった vim で開いて :so そのあと :call Test_xxx() 開くときに -Nu NONE --clean を付けるのを忘れない様に。

ゴリラ [08:26]



  簡単にやりたいなら書いた test_xxx.vim を出来上がった vim で開いて :so そのあと :call Test_xxx() 開くときに -Nu NONE --clean を付けるのを忘れない様に。



一旦↑でやりましたが何も出なかったので通ったってことかな…

Loading history...

メッセージ入力





#dev へのメッセージ
